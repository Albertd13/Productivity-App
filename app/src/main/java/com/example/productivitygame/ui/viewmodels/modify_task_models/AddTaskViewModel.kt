package com.example.productivitygame.ui.viewmodels.modify_task_models

import androidx.compose.material3.DatePickerState
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.SavedStateHandle
import com.example.productivitygame.data.RecurringType
import com.example.productivitygame.data.dao.RecurringCatAndTaskDao
import com.example.productivitygame.notifications.NotificationExactScheduler
import com.example.productivitygame.ui.screens.AddTaskDestination
import com.example.productivitygame.ui.utils.Result
import com.example.productivitygame.ui.utils.getAlarmItem
import com.example.productivitygame.ui.utils.getRecurringCat
import com.example.productivitygame.ui.utils.toTask
import com.example.productivitygame.ui.utils.toUtcDate
import kotlinx.datetime.DateTimeUnit
import kotlinx.datetime.isoDayNumber
import kotlinx.datetime.plus
import java.util.Locale


class AddTaskViewModel(
    private val recurringCatAndTaskDao: RecurringCatAndTaskDao,
    private val notificationExactScheduler: NotificationExactScheduler,
    savedStateHandle: SavedStateHandle
): ModifyTaskViewModel() {
    private val preselectedDateInMillis: Long = checkNotNull(savedStateHandle[AddTaskDestination.selectedDateInUTCMillisArg])

    override var taskUiState by mutableStateOf(
        TaskUiState(
        taskDetails = TaskDetails(date = preselectedDateInMillis.toUtcDate())
    )
    )

    @OptIn(ExperimentalMaterial3Api::class)
    override var datePickerState by mutableStateOf(DatePickerState(
        yearRange = 2024..2025,
        locale = Locale.getDefault(),
        initialSelectedDateMillis = preselectedDateInMillis,
        selectableDates = getCurrentSelectableDates()
    ))

    //for Weekly Recurring types, save an activity for each selected day, with date modified to fit day
    suspend fun saveItem() {
        if (validateInput() is Result.Success) {
            with(taskUiState.taskDetails){
                var taskList =
                    if (recurringType?.let { it::class } == RecurringType.Weekly::class){
                        val startDayIsoNr = (date!!.dayOfWeek).isoDayNumber
                        buildList {
                            selectedDays.forEach {
                                val daysToAdd = (it.isoDayNumber - startDayIsoNr).mod(7)
                                val newDate = date.plus(daysToAdd, DateTimeUnit.DAY)
                                add(taskUiState.taskDetails.copy(date = newDate).toTask())
                            }
                        }
                    } else listOf(toTask())
                // Inserted Tasks returned in order to schedule notifications with autogenerated id values
                taskList = recurringCatAndTaskDao.insertAndReturnRecurringTasks(
                    recurringCategory = getRecurringCat(),
                    insertedTasks = taskList
                )
                taskList.forEach {
                    if (it.notificationsEnabled)
                        notificationExactScheduler.scheduleNotification(
                            it.getAlarmItem()
                        )
                }
            }
        }
    }
}

